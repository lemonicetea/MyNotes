{
    "root": {
        "data": {
            "id": "cgxlecknty80",
            "created": 1641370827495,
            "text": "DDIA"
        },
        "children": [
            {
                "data": {
                    "id": "cigtcnh27qo0",
                    "created": 1646979060989,
                    "text": "数据系统基石（单台机器）"
                },
                "children": [
                    {
                        "data": {
                            "id": "cgxlexdnae80",
                            "created": 1641370872783,
                            "text": "非功能性需求"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cgxlf3umi600",
                                    "created": 1641370886870,
                                    "text": "可靠性",
                                    "note": "人们对于一个东西是否可靠，都有一个直观的想法。人们对可靠软件的典型期望包括：\n- 应用程序表现出用户所期望的功能。\n- 允许用户犯错，允许用户以出乎意料的方式使用软件。\n- 在预期的负载和数据量下，性能满足要求。\n- 系统能防止未经授权的访问和滥用。\n造成错误的原因叫做故障（fault）不同于失效（failure），故障的概率不可能降到零，因此最好设计容错机制以防因故障而导致失效。"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cgxlfl3sbww0",
                                            "created": 1641370924430,
                                            "text": "硬件故障（hardware faults）",
                                            "note": "通常认为硬件故障是随机的、相互独立的。\n一般是增加冗余来提高可用性，但是相应的硬件故障率也会提高，要根据系统优先考虑因素决定。\n在冗余的基础上进一步引入软件容错机制会更好。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cgxljfhrkuw0",
                                            "created": 1641371225671,
                                            "text": "软件错误"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cgyd5axd0yo0",
                                            "created": 1641449109709,
                                            "text": "人为错误"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "cgxlf61ly2g0",
                                    "created": 1641370891646,
                                    "text": "可伸缩性/可扩展性(Scalability)",
                                    "note": "用来描述系统应对负载增长能力的术语。"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "ch1nz7sxzg00",
                                            "created": 1641784344806,
                                            "text": "如何描述负载"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "cgxlf9qfw5c0",
                                    "created": 1641370899678,
                                    "text": "可维护性"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "cigtctgz0q80",
                    "created": 1646979074045,
                    "text": "分布式数据（多台机器）"
                },
                "children": [
                    {
                        "data": {
                            "id": "cigugbr9zts0",
                            "created": 1646982170052,
                            "text": "副本 Replication",
                            "note": "使用副本主要出于以下几个目的：\n- 高可用性\n即使在一台机器（或多台机器，或整个数据中心）停机的情况下也能保持系统正常运行\n- 断开连接的操作\n允许应用程序在网络中断时继续工作\n- 延迟\n将数据放置在距离用户较近的地方，以便用户能够更快地与其交互\n- 可伸缩性\n通过在副本上读，能够处理比单机更大的读取量"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cihtwu92kq00",
                                    "created": 1647082202984,
                                    "text": "单主复制",
                                    "note": "客户端将所有写入操作发送到单个节点（领导者），该节点将数据更改事件流发送到其他副本（追随者）。读取可以在任何副本上执行，但从追随者读取可能是陈旧的。"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "ciguhcda5q80",
                                            "created": 1646982249747,
                                            "text": "主从",
                                            "note": "客户端将所有写入操作发送到单个节点（主/领导者），该节点将数据更改事件流发送到其他副本（从/追随者）。读取可以在任何副本上执行，但从追随者读取可能是陈旧的（因为可能使用了异步的复制机制）。"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "cigujmd5jkw0",
                                                    "created": 1646982428235,
                                                    "text": "同步复制or异步复制"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "cihqbcjwvlc0",
                                                    "created": 1647072055480,
                                                    "text": "泵机",
                                                    "note": "- 从库泵机：从日志中知道发生故障前处理的最后一个事物，追赶恢复\n- 主库泵机：故障切换。从从库中选取一个新主库，会存在各种各样的问题，虽然很多系统提供了自动故障切换，但还是手工运维处理故障可靠性更高"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "cihr0xr57a80",
                                                    "created": 1647074060734,
                                                    "text": "基于主库的复制 底层逻辑",
                                                    "note": "- 基于语句的复制\n  每个从库都执行相同的SQL，这样的问题是若使用生成随机数的方法（如时间、自增序列等），会在每个从上产生不同的效果，从而造成副作用。\n- 传输预写式日志（WAL）\n  写操作追加到日志中\n- 逻辑日志复制（基于行）\n  \n- 基于触发器的复制\n  "
                                                },
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "data": {
                                            "id": "ciguhe6rjps0",
                                            "created": 1646982253707,
                                            "text": "复制滞后问题",
                                            "note": "主负责写入，各从负责被读。数据从主到从存在复制延迟"
                                        },
                                        "children": [
                                            {
                                                "data": {
                                                    "id": "cihrlgfq8m80",
                                                    "created": 1647075668686,
                                                    "text": "读己之写",
                                                    "note": "对于用户写入后立马就需要读的场景可以考虑读己之写，向主库发送读的请求，来保障读写一致性。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "cihsiambmjs0",
                                                    "created": 1647078242041,
                                                    "text": "单调读",
                                                    "note": "对于用户先从新副本读取，然后从旧副本读取，发生了“时光倒流”的场景，可以考虑单调读取。\n实现单调读取的一种方式是确保每个用户总是从同一个副本进行读取（不同的用户可以从不同的副本读取）。例如，可以基于用户 ID 的散列来选择副本，而不是随机选择副本。但是，如果该副本失败，用户的查询将需要重新路由到另一个副本。"
                                                },
                                                "children": []
                                            },
                                            {
                                                "data": {
                                                    "id": "cihsn66uxwo0",
                                                    "created": 1647078624220,
                                                    "text": "一致前缀读",
                                                    "note": "如果一系列写入按某个顺序发生，那么任何人读取这些写入时，也会看见它们以同样的顺序出现。"
                                                },
                                                "children": []
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "ciguhhau2xk0",
                                    "created": 1646982260483,
                                    "text": "多主复制",
                                    "note": "对于运维多个数据中心（或分区），可以考虑多主的场景，在每个数据中心都设置一个主，称之为 多领导者配置（也称多主、多活复制）。 在这种情况下，每个领导者同时扮演其他领导者的追随者。\n客户端发送每个写入到几个领导节点之一，其中任何一个都可以接受写入。领导者将数据更改事件流发送给彼此以及任何跟随者节点。"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cihtv7w3q0w0",
                                            "created": 1647082075946,
                                            "text": "处理写入冲突",
                                            "note": "多个操作并发修改了同一条记录中的同一个字段并设置为了不同的值，这样是会产生冲突的"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cihtvcy10zc0",
                                            "created": 1647082086947,
                                            "text": "多主复制拓扑",
                                            "note": "多个主之间的复制顺序问题\n环状、星状、树状等"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "ciguib75ni00",
                                    "created": 1646982325564,
                                    "text": "无主复制",
                                    "note": "客户端发送每个写入到几个节点，并从多个节点并行读取，以检测和纠正具有陈旧数据的节点。"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cihwn3hf4wo0",
                                            "created": 1647089902768,
                                            "text": "节点故障时读写：nrw原则",
                                            "note": "如果有 n 个副本，每个写入必须由 w 节点确认才能被认为是成功的，并且我们必须至少为每个读取查询 r 个节点。\n设置 w = r =（n + 1）/ 2w=r=（n+1）/2（向上取整），或者w + r > n"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cihxaqfnufc0",
                                            "created": 1647091755103,
                                            "text": "解决并发写入问题",
                                            "note": "- 通过时间戳等手段判断先后顺序，使用LWW（Last Write Wins）覆盖\n- 如果是同时发生的，则通过合并并发更新来解决冲突"
                                        },
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "cigugyp0ixs0",
                            "created": 1646982219982,
                            "text": "分区 Partitioning",
                            "note": "在多台机器上均匀分布数据和查询负载，避免出现热点（负载不成比例的节点）。这需要选择适合于你的数据的分区方案，并在将节点添加到集群或从集群删除时进行分区再平衡。"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cihzr87kbdk0",
                                    "created": 1647098689842,
                                    "text": "键值数据分区",
                                    "note": "依赖于键值数据模型\n通过主键访问记录，我们可以从该键确定分区，并使用它来将读写请求路由到负责该键的分区。"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cihzs6a5row0",
                                            "created": 1647098764010,
                                            "text": "根据键的范围分区",
                                            "note": "优势在于可以进行有效的范围查询，但是如果应用程序经常访问相邻的键，则存在热点的风险。\n\n在这种方法中，当分区变得太大时，通常将分区分成两个子分区，动态地再平衡分区。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cihzscpxoo80",
                                            "created": 1647098778024,
                                            "text": "根据键的散列分区",
                                            "note": "散列函数应用于每个键，分区拥有一定范围的散列。这种方法破坏了键的排序，使得范围查询效率低下，但可以更均匀地分配负载。\n\n通过散列进行分区时，通常先提前创建固定数量的分区，为每个节点分配多个分区，并在添加或删除节点时将整个分区从一个节点移动到另一个节点。也可以使用动态分区。"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "cihzvgo0g600",
                                    "created": 1647099021708,
                                    "text": "分区与次级索引",
                                    "note": "次级索引通常并不能唯一地标识记录，而是一种搜索记录中出现特定值的方式"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cihzwz9dht40",
                                            "created": 1647099140545,
                                            "text": "基于文档的次级索引分区",
                                            "note": "其中次级索引存储在与主键和值相同的分区中。这意味着只有一个分区需要在写入时更新，但是读取次级索引需要在所有分区之间进行分散 / 收集。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cihzx63sm2g0",
                                            "created": 1647099155446,
                                            "text": "基于关键词的次级索引分区",
                                            "note": "其中次级索引存在不同的分区中。次级索引中的条目可以包括来自主键的所有分区的记录。当文档写入时，需要更新多个分区中的次级索引；但是可以从单个分区中进行读取。"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "cii0276n1c00",
                                    "created": 1647099549615,
                                    "text": "分区再平衡",
                                    "note": "将负载从集群中的一个节点向另一个节点移动的过程称为 再平衡。\n\n再平衡通常都要满足一些最低要求：\n- 再平衡之后，负载（数据存储，读取和写入请求）应该在集群中的节点之间公平地共享。\n- 再平衡发生时，数据库应该继续接受读取和写入。\n- 节点之间只移动必须的数据，以便快速再平衡，并减少网络和磁盘 I/O 负载。"
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cii03dmss2o0",
                                            "created": 1647099642017,
                                            "text": "固定数量的分区策略",
                                            "note": "创建比节点更多的分区，并为每个节点分配多个分区。这样节点可以动态扩容，只要保障分区数量不变即可。\n比如增加新节点时，可以从当前每个节点中挪取一些分区直到平均；或者删除一个节点时，将该节点上的分区均分到剩余节点上。\n只有分区在节点之间的移动。分区的数量不会改变，键所指定的分区也不会改变。唯一改变的是分区所在的节点。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cii08j0tx0o0",
                                            "created": 1647100045571,
                                            "text": "动态分区策略",
                                            "note": "当分区增长到超过配置的大小时，会被分成两个分区，每个分区约占一半的数据，反之亦然。\n动态分区的一个优点是分区数量适应总数据量。如果只有少量的数据，少量的分区就足够了，所以开销很小；如果有大量的数据，每个分区的大小被限制在一个可配置的最大值。"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cii0a883vag0",
                                            "created": 1647100178794,
                                            "text": "按节点比例分区策略",
                                            "note": "每个节点具有固定数量的分区。\n当一个新节点加入集群时，它随机选择固定数量的现有分区进行拆分，然后占有这些拆分分区中每个分区的一半，同时将每个分区的另一半留在原地。"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "cii0c27nk340",
                                    "created": 1647100322434,
                                    "text": "请求路由",
                                    "note": "几种不同的方案:\n- 允许客户联系任何节点（例如，通过 循环策略的负载均衡）。如果该节点恰巧拥有请求的分区，则它可以直接处理该请求；否则，它将请求转发到适当的节点，接收回复并传递给客户端。\n- 首先将所有来自客户端的请求发送到路由层，它决定了应该处理请求的节点，并相应地转发。此路由层本身不处理任何请求；它仅负责分区的负载均衡。\n- 要求客户端知道分区和节点的分配。在这种情况下，客户端可以直接连接到适当的节点，而不需要任何中介。\n- 依赖于一个独立的协调服务，比如 ZooKeeper 来跟踪集群元数据，每个节点在 ZooKeeper 中注册自己，ZooKeeper 维护分区到节点的可靠映射。 其他参与者（如路由层或分区感知客户端）可以在 ZooKeeper 中订阅此信息。 只要分区分配发生了改变，或者集群中添加或删除了一个节点，ZooKeeper 就会通知路由层使路由信息保持最新状态。"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "template": "right",
    "theme": "fresh-blue",
    "version": "1.4.43"
}