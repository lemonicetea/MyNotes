{
    "root": {
        "data": {
            "id": "cif7lifed800",
            "created": 1646816130908,
            "text": "System Design Interviews"
        },
        "children": [
            {
                "data": {
                    "id": "cif7lmxu8400",
                    "created": 1646816140730,
                    "text": "原则",
                    "expandState": "collapse"
                },
                "children": [
                    {
                        "data": {
                            "id": "cif7mfw5vi80",
                            "created": 1646816203755,
                            "text": "需求澄清",
                            "note": "描述使用场景，约束和假设\n- 谁会使用它？\n- 他们会怎样使用它？\n- 有多少用户？\n- 系统的作用是什么？\n- 系统的输入输出分别是什么？\n- 我们希望处理多少数据？\n- 我们希望每秒钟处理多少请求？\n- 我们希望的读写比率？"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cinmyu0oxhs0",
                            "created": 1647671971176,
                            "text": "创造一个高层次的设计",
                            "note": "使用所有重要的组件来描绘出一个高层级的设计。\n- 画出主要的组件和连接\n- 证明你的想法"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cinmzdliztk0",
                            "created": 1647672013795,
                            "text": "设计核心组件",
                            "expandState": "expand"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cif7msywqxs0",
                                    "created": 1646816232220,
                                    "text": "粗略的估计"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cif7mla8iog0",
                                    "created": 1646816215490,
                                    "text": "系统接口定义"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cif7mxlbx000",
                                    "created": 1646816242282,
                                    "text": "定义数据模型"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cif7n6kf4yw0",
                                    "created": 1646816261818,
                                    "text": "详细设计"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "cif7nh32luo0",
                            "created": 1646816284714,
                            "text": "扩展设计：识别并解决瓶颈",
                            "note": "- 负载均衡\n- 水平扩展\n- 缓存\n- 数据库分片"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cinn6we2bxc0",
                    "created": 1647672603252,
                    "text": "性能与扩展性"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cinn75shl340",
                    "created": 1647672623715,
                    "text": "延迟与吞吐量"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cinn79mrgns0",
                    "created": 1647672632076,
                    "text": "可用性与一致性",
                    "expandState": "collapse"
                },
                "children": [
                    {
                        "data": {
                            "id": "cinn7dmusnc0",
                            "created": 1647672640788,
                            "text": "CAP理论",
                            "expandState": "expand"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cinn7jd67140",
                                    "created": 1647672653264,
                                    "text": "CP：一致性和分区容错性"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cinn7p4r3vk0",
                                    "created": 1647672665815,
                                    "text": "AP：可用性和分区容错性"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cinn7vy460g0",
                                    "created": 1647672680651,
                                    "text": "一致模式"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cinn7zt8lf40",
                                    "created": 1647672689064,
                                    "text": "可用模式"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "cinn835bmxk0",
                    "created": 1647672696325,
                    "text": "域名系统",
                    "note": "把域名转换成IP，访问DNS时可能有以下几种情况：\n- NS 记录（域名服务） ─ 指定解析域名或子域名的 DNS 服务器。\n- MX 记录（邮件交换） ─ 指定接收信息的邮件服务器。\n- A 记录（地址） ─ 指定域名对应的 IP 地址记录。\n- CNAME（规范） ─ 一个域名映射到另一个域名或 CNAME 记录（ example.com 指向 www.example.com ）或映射到一个 A 记录。\n\n缺点：\n- 虽说缓存可以减轻 DNS 延迟，但连接 DNS 服务器还是带来了轻微的延迟。\n- 虽然它们通常由政府，网络服务提供商和大公司管理，但 DNS 服务管理仍可能是复杂的。\n- DNS 服务最近遭受 DDoS 攻击，阻止不知道 Twitter IP 地址的用户访问 Twitter。"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cinn88jfmjk0",
                    "created": 1647672708062,
                    "text": "内容分发网络（CDN）",
                    "note": "是一个全球性的代理服务器分布式网络，它从靠近用户的位置提供内容。通常，HTML/CSS/JS，图片和视频等静态内容由 CDN 提供。\n将内容存储在 CDN 上可以从两个方面来提供性能:\n- 从靠近用户的数据中心提供资源\n- 通过 CDN 你的服务器不必真的处理请求\n\n缺点：\n- CDN 成本可能因流量而异，可能在权衡之后你将不会使用 CDN。\n- 如果在 TTL 过期之前更新内容，CDN 缓存内容可能会过时。\n- CDN 需要更改静态内容的 URL 地址以指向 CDN。"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cinn8bb52so0",
                    "created": 1647672714091,
                    "text": "负载均衡器",
                    "note": "负载均衡器将传入的请求分发到应用服务器和数据库等计算资源。无论哪种情况，负载均衡器将从计算资源来的响应返回给恰当的客户端。负载均衡器的效用在于:\n- 防止请求进入不好的服务器\n- 防止资源过载\n- 帮助消除单一的故障点\n\n加的好处包括:\n- SSL 终结 ─ 解密传入的请求并加密服务器响应，这样的话后端服务器就不必再执行这些潜在高消耗运算了。不需要再每台服务器上安装 X.509 证书。\n- Session 留存 ─ 如果 Web 应用程序不追踪会话，发出 cookie 并将特定客户端的请求路由到同一实例。\n\n通常会设置采用工作─备用 或 双工作 模式的多个负载均衡器，以免发生故障。\n\n缺点：\n- 如果没有足够的资源配置或配置错误，负载均衡器会变成一个性能瓶颈。\n- 引入负载均衡器以帮助消除单点故障但导致了额外的复杂性。\n- 单个负载均衡器会导致单点故障，但配置多个负载均衡器会进一步增加复杂性。\n"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cinn8m59u6w0",
                    "created": 1647672737680,
                    "text": "反向代理（web服务器）",
                    "note": "反向代理是一种可以集中地调用内部服务，并提供统一接口给公共客户的 web 服务器。来自客户端的请求先被反向代理服务器转发到可响应请求的服务器，然后代理再把服务器的响应结果返回给客户端。\n\n好处：\n- 增加安全性 - 隐藏后端服务器的信息，屏蔽黑名单中的 IP，限制每个客户端的连接数。\n- 提高可扩展性和灵活性 - 客户端只能看到反向代理服务器的 IP，这使你可以增减服务器或者修改它们的配置。\n- 本地终结 SSL 会话 - 解密传入请求，加密服务器响应，这样后端服务器就不必完成这些潜在的高成本的操作。免除了在每个服务器上安装 X.509 证书的需要\n- 压缩 - 压缩服务器响应\n- 缓存 - 直接返回命中的缓存结果\n- 静态内容 - 直接提供静态内容\n\n缺点：\n- 引入反向代理会增加系统的复杂度。\n- 单独一个反向代理服务器仍可能发生单点故障，配置多台反向代理服务器（如故障转移）会进一步增加复杂度。"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cinn8zpocdc0",
                    "created": 1647672767212,
                    "text": "应用层",
                    "note": "将 Web 服务层与应用层（也被称作平台层）分离，可以独立缩放和配置这两层。\n单一职责原则提倡小型的，自治的服务共同合作。\n\n缺点：\n- 添加由多个松耦合服务组成的应用层，从架构、运营、流程等层面来讲将非常不同（相对于单体系统）。\n- 微服务会增加部署和运营的复杂度。"
                },
                "children": [
                    {
                        "data": {
                            "id": "cinozitslsw0",
                            "created": 1647677667398,
                            "text": "微服务",
                            "note": "可以被描述为一系列可以独立部署的小型的，模块化服务。每个服务运行在一个独立的线程中，通过明确定义的轻量级机制通讯，共同实现业务目标。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cinp01udhi80",
                            "created": 1647677708792,
                            "text": "服务发现",
                            "note": "像 Consul，Etcd 和 Zookeeper 这样的系统可以通过追踪注册名、地址、端口等信息来帮助服务互相发现对方。Health checks 可以帮助确认服务的完整性和是否经常使用一个 HTTP 路径。Consul 和 Etcd 都有一个内建的 key-value 存储 用来存储配置信息和其他的共享信息。"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cinn94ruvmg0",
                    "created": 1647672778228,
                    "text": "数据库"
                },
                "children": [
                    {
                        "data": {
                            "id": "cinn9ajcimw0",
                            "created": 1647672790774,
                            "text": "关系型数据库",
                            "note": "以表的形式组织的数据项集合。\n\nACID 用来描述关系型数据库事务的特性：\n\n原子性 - 每个事务内部所有操作要么全部完成，要么全部不完成。\n一致性 - 任何事务都使数据库从一个有效的状态转换到另一个有效状态。\n隔离性 - 并发执行事务的结果与顺序执行事务的结果相同。\n持久性 - 事务提交后，对系统的影响是永久的。"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cinpcd30a3k0",
                                    "created": 1647678673629,
                                    "text": "主从",
                                    "note": "主库同时负责读取和写入操作，并复制写入到一个或多个从库中，从库只负责读操作。树状形式的从库再将写入复制到更多的从库中去。如果主库离线，系统可以以只读模式运行，直到某个从库被提升为主库或有新的主库出现。\n\n缺点：\n- 将从库提升为主库需要额外的逻辑。\n- 参考不利之处：复制中，主从复制和主主复制共同的问题。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cinpcuu20ow0",
                                    "created": 1647678712270,
                                    "text": "主主",
                                    "note": "两个主库都负责读操作和写操作，写入操作时互相协调。如果其中一个主库挂机，系统可以继续读取和写入。\n\n缺点：\n- 你需要添加负载均衡器或者在应用逻辑中做改动，来确定写入哪一个数据库。\n- 多数主-主系统要么不能保证一致性（违反 ACID），要么因为同步产生了写入延迟。\n- 随着更多写入节点的加入和延迟的提高，如何解决冲突显得越发重要。\n- 参考不利之处：复制中，主从复制和主主复制共同的问题。\n\n复制时的问题：\n- 如果主库在将新写入的数据复制到其他节点前挂掉，则有数据丢失的可能。\n- 写入会被重放到负责读取操作的副本。副本可能因为过多写操作阻塞住，导致读取功能异常。\n- 读取从库越多，需要复制的写入数据就越多，导致更严重的复制延迟。\n- 在某些数据库系统中，写入主库的操作可以用多个线程并行写入，但读取副本只支持单线程顺序地写入。\n- 复制意味着更多的硬件和额外的复杂度。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cinpdvygeg00",
                                    "created": 1647678793077,
                                    "text": "联合",
                                    "note": "联合（或按功能划分）将数据库按对应功能分割。例如，你可以有三个数据库：论坛、用户和产品，而不仅是一个单体数据库，从而减少每个数据库的读取和写入流量，减少复制延迟。较小的数据库意味着更多适合放入内存的数据，进而意味着更高的缓存命中几率。没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。\n\n缺点：\n- 如果你的数据库模式需要大量的功能和数据表，联合的效率并不好。\n- 你需要更新应用程序的逻辑来确定要读取和写入哪个数据库。\n- 用 server link 从两个库联结数据更复杂。\n- 联合需要更多的硬件和额外的复杂度。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cinpemjd9wg0",
                                    "created": 1647678850938,
                                    "text": "分片",
                                    "note": "分片将数据分配在不同的数据库上，使得每个数据库仅管理整个数据集的一个子集。以用户数据库为例，随着用户数量的增加，越来越多的分片会被添加到集群中。\n类似联合的优点，分片可以减少读取和写入流量，减少复制并提高缓存命中率。也减少了索引，通常意味着查询更快，性能更好。如果一个分片出问题，其他的仍能运行，你可以使用某种形式的冗余来防止数据丢失。类似联合，没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。\n常见的做法是用户姓氏的首字母或者用户的地理位置来分隔用户表。\n\n缺点：\n- 你需要修改应用程序的逻辑来实现分片，这会带来复杂的 SQL 查询。\n- 分片不合理可能导致数据负载不均衡。例如，被频繁访问的用户数据会导致其所在分片的负载相对其他分片高。再平衡会引入额外的复杂度。基于一致性哈希的分片算法可以减少这种情况。\n- 联结多个分片的数据操作更复杂。\n- 分片需要更多的硬件和额外的复杂度。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cinpkfitkug0",
                                    "created": 1647679305852,
                                    "text": "非规范化",
                                    "note": "非规范化试图以写入性能为代价来换取读取性能。在多个表中冗余数据副本，以避免高成本的联结操作。一些关系型数据库，比如 PostgreSQL 和 Oracle 支持物化视图，可以处理冗余信息存储和保证冗余副本一致。\n当数据使用诸如联合和分片等技术被分割，进一步提高了处理跨数据中心的联结操作复杂度。非规范化可以规避这种复杂的联结操作。\n\n缺点：\n- 数据会冗余。\n- 约束可以帮助冗余的信息副本保持同步，但这样会增加数据库设计的复杂度。\n- 非规范化的数据库在高写入负载下性能可能比规范化的数据库差"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "cinn9e135oo0",
                            "created": 1647672798377,
                            "text": "NoSQL",
                            "note": "数据库是非规范化的，表联结大多在应用程序代码中完成。大多数 NoSQL 无法实现真正符合 ACID 的事务，支持最终一致。\n\nBASE 通常被用于描述 NoSQL 数据库的特性。相比 CAP 理论，BASE 强调可用性超过一致性。\n\n基本可用 - 系统保证可用性。\n软状态 - 即使没有输入，系统状态也可能随着时间变化。\n最终一致性 - 经过一段时间之后，系统最终会变一致，因为系统在此期间没有收到任何输入。\n\n"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cintcixugu80",
                                    "created": 1647689970817,
                                    "text": "键-值数据库",
                                    "note": "抽象模型：哈希表\n键-值存储通常可以实现 O(1) 时间读写，用内存或 SSD 存储数据。数据存储可以按字典顺序维护键，从而实现键的高效检索。键-值存储可以用于存储元数据。\n键-值存储性能很高，通常用于存储简单数据模型或频繁修改的数据，如存放在内存中的缓存。键-值存储提供的操作有限，如果需要更多操作，复杂度将转嫁到应用程序层面。\n键-值存储是如文档存储，在某些情况下，甚至是图存储等更复杂的存储系统的基础。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cintczpcc800",
                                    "created": 1647690007308,
                                    "text": "文档型数据库",
                                    "note": "抽象模型：将文档作为值的键-值存储\n文档类型存储以文档（XML、JSON、二进制文件等）为中心，文档存储了指定对象的全部信息。文档存储根据文档自身的内部结构提供 API 或查询语句来实现查询。请注意，许多键-值存储数据库有用值存储元数据的特性，这也模糊了这两种存储类型的界限。\n基于底层实现，文档可以根据集合、标签、元数据或者文件夹组织。尽管不同文档可以被组织在一起或者分成一组，但相互之间可能具有完全不同的字段。\nMongoDB 和 CouchDB 等一些文档类型存储还提供了类似 SQL 语言的查询语句来实现复杂查询。DynamoDB 同时支持键-值存储和文档类型存储。\n文档类型存储具备高度的灵活性，常用于处理偶尔变化的数据。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cintd44sh480",
                                    "created": 1647690016949,
                                    "text": "列型数据库",
                                    "note": "抽象模型：嵌套的ColumnFamily<RowKey, Columns<ColKey, Value, Timestamp>> 映射\n\n类型存储的基本数据单元是列（名／值对）。列可以在列族（类似于 SQL 的数据表）中被分组。超级列族再分组普通列族。你可以使用行键独立访问每一列，具有相同行键值的列组成一行。每个值都包含版本的时间戳用于解决版本冲突。\n\nGoogle 发布了第一个列型存储数据库 Bigtable，它影响了 Hadoop 生态系统中活跃的开源数据库 HBase 和 Facebook 的 Cassandra。像 BigTable，HBase 和 Cassandra 这样的存储系统将键以字母顺序存储，可以高效地读取键列。\n\n列型存储具备高可用性和高可扩展性。通常被用于大数据相关存储。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cintdboii7s0",
                                    "created": 1647690033380,
                                    "text": "图数据库",
                                    "note": "抽象模型： 图\n\n在图数据库中，一个节点对应一条记录，一个弧对应两个节点之间的关系。图数据库被优化用于表示外键繁多的复杂关系或多对多关系。\n\n图数据库为存储复杂关系的数据模型，如社交网络，提供了很高的性能。它们相对较新，尚未广泛应用，查找开发工具或者资源相对较难。许多图只能通过 REST API 访问。"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "cinn9jgqpm80",
                    "created": 1647672810208,
                    "text": "缓存",
                    "note": "缓存可以提高页面加载速度，并可以减少服务器和数据库的负载。在这个模型中，分发器先查看请求之前是否被响应过，如果有则将之前的结果直接返回，来省掉真正的处理。\n\n数据库分片均匀分布的读取是最好的。但是热门数据会让读取分布不均匀，这样就会造成瓶颈，如果在数据库前加个缓存，就会抹平不均匀的负载和突发流量对数据库的影响。\n\n缺点：\n- 需要保持缓存和真实数据源之间的一致性，比如数据库根据缓存无效。\n- 需要改变应用程序比如增加 Redis 或者 memcached。\n- 无效缓存是个难题，什么时候更新缓存是与之相关的复杂问题。"
                },
                "children": [
                    {
                        "data": {
                            "id": "cinv1prg63k0",
                            "created": 1647694765882,
                            "text": "缓存类型",
                            "note": "- 缓存可以位于客户端（操作系统或者浏览器），服务端或者不同的缓存层。\n\n- CDN 也被视为一种缓存。\n\n- 反向代理和缓存（比如 Varnish）可以直接提供静态和动态内容。Web 服务器同样也可以缓存请求，返回相应结果而不必连接应用服务器。\n\n- 应用缓存。基于内存的缓存比如 Memcached 和 Redis 是应用程序和数据存储之间的一种键值存储。由于数据保存在 RAM 中，它比存储在磁盘上的典型数据库要快多了。RAM 比磁盘限制更多，所以例如 least recently used (LRU) 的缓存无效算法可以将「热门数据」放在 RAM 中，而对一些比较「冷门」的数据不做处理。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cinv1xhobj40",
                            "created": 1647694782705,
                            "text": "缓存级别"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cinv3ft1cwo0",
                                    "created": 1647694900938,
                                    "text": "数据库查询级别的缓存",
                                    "note": "当你查询数据库的时候，将查询语句的哈希值与查询结果存储到缓存中。这种方法会遇到以下问题：\n\n- 很难用复杂的查询删除已缓存结果。\n- 如果一条数据比如表中某条数据的一项被改变，则需要删除所有可能包含已更改项的缓存结果。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cinv4feyyn40",
                                    "created": 1647694978452,
                                    "text": "对象级别的缓存",
                                    "note": "将您的数据视为对象，就像对待你的应用代码一样。让应用程序将数据从数据库中组合到类实例或数据结构中：\n\n- 如果对象的基础数据已经更改了，那么从缓存中删掉这个对象。\n- 允许异步处理：workers 通过使用最新的缓存对象来组装对象。\n\n建议缓存的内容：\n\n- 用户会话\n- 完全渲染的 Web 页面\n- 活动流\n- 用户图数据"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "cinv7xxqin40",
                            "created": 1647695253861,
                            "text": "更新策略",
                            "note": "由于你只能在缓存中存储有限的数据，所以你需要选择一个适用于你用例的缓存更新策略。"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cinv83ijqew0",
                                    "created": 1647695266004,
                                    "text": "缓存模式",
                                    "note": "应用从存储器读写。缓存不和存储器直接交互，应用执行以下操作：\n\n- 在缓存中查找记录，如果所需数据不在缓存中\n- 从数据库中加载所需内容\n- 将查找到的结果存储到缓存中\n- 返回所需内容\n\n添加到缓存中的数据读取速度很快。缓存模式也称为延迟加载。只缓存所请求的数据，这避免了没有被请求的数据占满了缓存空间。\n\n缺点：\n- 请求的数据如果不在缓存中就需要经过三个步骤来获取数据，这会导致明显的延迟。\n- 如果数据库中的数据更新了会导致缓存中的数据过时。这个问题需要通过设置 TTL 强制更新缓存或者直写模式来缓解这种情况。\n- 当一个节点出现故障的时候，它将会被一个新的节点替代，这增加了延迟的时间。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cinvahz9c680",
                                    "created": 1647695454217,
                                    "text": "直写模式",
                                    "note": "应用使用缓存作为主要的数据存储，将数据读写到缓存中，而缓存负责从数据库中读写数据。\n\n- 应用向缓存中添加/更新数据\n- 缓存同步地写入数据存储\n- 返回所需内容\n\n由于存写操作所以直写模式整体是一种很慢的操作，但是读取刚写入的数据很快。相比读取数据，用户通常比较能接受更新数据时速度较慢。缓存中的数据不会过时。\n\n缺点：\n- 由于故障或者缩放而创建的新的节点，新的节点不会缓存，直到数据库更新为止。缓存应用直写模式可以缓解这个问题。\n- 写入的大多数数据可能永远都不会被读取，用 TTL 可以最小化这种情况的出现。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cinvcx3uddk0",
                                    "created": 1647695643875,
                                    "text": "回写模式",
                                    "note": "在回写模式中，应用执行以下操作：\n- 在缓存中增加或者更新条目\n- 异步写入数据，提高写入性能。\n\n缺点：\n- 缓存可能在其内容成功存储之前丢失数据。\n- 执行直写模式比缓存或者回写模式更复杂。"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cinveibcqvc0",
                                    "created": 1647695768405,
                                    "text": "刷新",
                                    "note": "你可以将缓存配置成在到期之前自动刷新最近访问过的内容。\n\n如果缓存可以准确预测将来可能请求哪些数据，那么刷新可能会导致延迟与读取时间的降低。\n\n缺点：\n- 不能准确预测到未来需要用到的数据可能会导致性能不如不使用刷新。"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "cinn9xw69tc0",
                    "created": 1647672841616,
                    "text": "异步",
                    "note": "异步工作流有助于减少那些原本顺序执行的请求时间。它们可以通过提前进行一些耗时的工作来帮助减少请求时间，比如定期汇总数据。\n\n背压：\n如果队列开始明显增长，那么队列大小可能会超过内存大小，导致高速缓存未命中，磁盘读取，甚至性能更慢。背压可以通过限制队列大小来帮助我们，从而为队列中的作业保持高吞吐率和良好的响应时间。一旦队列填满，客户端将得到服务器忙或者 HTTP 503 状态码，以便稍后重试。客户端可以在稍后时间重试该请求，也许是指数退避。\n\n缺点：\n- 简单的计算和实时工作流等用例可能更适用于同步操作，因为引入队列可能会增加延迟和复杂性。"
                },
                "children": [
                    {
                        "data": {
                            "id": "cinvk813ayg0",
                            "created": 1647696216202,
                            "text": "消息队列",
                            "note": "消息队列接收，保留和传递消息。如果按顺序执行操作太慢的话，你可以使用有以下工作流的消息队列：\n- 应用程序将作业发布到队列，然后通知用户作业状态\n- 一个 worker 从队列中取出该作业，对其进行处理，然后显示该作业完成\n\n不去阻塞用户操作，作业在后台处理。在此期间，客户端可能会进行一些处理使得看上去像是任务已经完成了。例如，如果要发送一条推文，推文可能会马上出现在你的时间线上，但是可能需要一些时间才能将你的推文推送到你的所有关注者那里去。\n\nRedis 是一个令人满意的简单的消息代理，但是消息有可能会丢失。\n\nRabbitMQ 很受欢迎但是要求你适应「AMQP」协议并且管理你自己的节点。\n\nAmazon SQS 是被托管的，但可能具有高延迟，并且消息可能会被传送两次。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cinvkamckb40",
                            "created": 1647696221841,
                            "text": "任务队列",
                            "note": "任务队列接收任务及其相关数据，运行它们，然后传递其结果。 它们可以支持调度，并可用于在后台运行计算密集型作业。\n\nCelery 支持调度，主要是用 Python 开发的。"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cinna1ztoo00",
                    "created": 1647672850544,
                    "text": "通讯"
                },
                "children": [
                    {
                        "data": {
                            "id": "cinwlch3s6w0",
                            "created": 1647699125351,
                            "text": "超文本传输协议（HTTP）",
                            "note": "HTTP 是一种在客户端和服务器之间编码和传输数据的方法。它是一个请求/响应协议：客户端和服务端针对相关内容和完成状态信息的请求和响应。HTTP 是独立的，允许请求和响应流经许多执行负载均衡，缓存，加密和压缩的中间路由器和服务器。\n\n一个基本的 HTTP 请求由一个动词（方法）和一个资源（端点）组成。\n\n多次执行不会产生不同的结果。\n\nHTTP 是依赖于较低级协议（如 TCP 和 UDP）的应用层协议。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cinwlp9s1280",
                            "created": 1647699153207,
                            "text": "传输控制协议（TCP）",
                            "note": "TCP 是通过 IP 网络的面向连接的协议。 使用握手建立和断开连接。 发送的所有数据包保证以原始顺序到达目的地，用以下措施保证数据包不被损坏：\n- 每个数据包的序列号和校验码。\n- 确认包和自动重传\n\n如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。TCP 实行流量控制和拥塞控制。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。\n\n为了确保高吞吐量，Web 服务器可以保持大量的 TCP 连接，从而导致高内存使用。在 Web 服务器线程间拥有大量开放连接可能开销巨大，消耗资源过多，也就是说，一个 memcached 服务器。连接池 可以帮助除了在适用的情况下切换到 UDP。\n\nTCP 对于需要高可靠性但时间紧迫的应用程序很有用。比如包括 Web 服务器，数据库信息，SMTP，FTP 和 SSH。\n\n以下情况使用 TCP 代替 UDP：\n- 你需要数据完好无损。\n- 你想对网络吞吐量自动进行最佳评估。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cinwlvtiwgo0",
                            "created": 1647699167461,
                            "text": "用户数据报协议（UDP）",
                            "note": "UDP 是无连接的。数据报（类似于数据包）只在数据报级别有保证。数据报可能会无序的到达目的地，也有可能会遗失。UDP 不支持拥塞控制。虽然不如 TCP 那样有保证，但 UDP 通常效率更高。\n\nUDP 可以通过广播将数据报发送至子网内的所有设备。这对 DHCP 很有用，因为子网内的设备还没有分配 IP 地址，而 IP 对于 TCP 是必须的。\n\nUDP 可靠性更低但适合用在网络电话、视频聊天，流媒体和实时多人游戏上。\n\n以下情况使用 UDP 代替 TCP：\n- 你需要低延迟\n- 相对于数据丢失更糟的是数据延迟\n- 你想实现自己的错误校正方法"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cinwm148da00",
                            "created": 1647699178993,
                            "text": "远程过程调用协议（RPC）",
                            "note": "在 RPC 中，客户端会去调用另一个地址空间（通常是一个远程服务器）里的方法。调用代码看起来就像是调用的是一个本地方法，客户端和服务器交互的具体过程被抽象。远程调用相对于本地调用一般较慢而且可靠性更差，因此区分两者是有帮助的。热门的 RPC 框架包括 Protobuf、Thrift 和 Avro。\n\nRPC 是一个“请求-响应”协议：\n- 客户端程序 ── 调用客户端存根程序。就像调用本地方法一样，参数会被压入栈中。\n- 客户端 stub 程序 ── 将请求过程的 id 和参数打包进请求信息中。\n- 客户端通信模块 ── 将信息从客户端发送至服务端。\n- 服务端通信模块 ── 将接受的包传给服务端存根程序。\n- 服务端 stub 程序 ── 将结果解包，依据过程 id 调用服务端方法并将参数传递过去。\n\n当以下情况时选择本地库（也就是 SDK）：\n- 你知道你的目标平台。\n- 你想控制如何访问你的“逻辑”。\n- 你想对发生在你的库中的错误进行控制。\n= 性能和终端用户体验是你最关心的事。\n\n遵循 REST 的 HTTP API 往往更适用于公共 API。\n\n缺点：\n- RPC 客户端与服务实现捆绑地很紧密。\n- 一个新的 API 必须在每一个操作或者用例中定义。\n- RPC 很难调试。\n- 你可能没办法很方便的去修改现有的技术。举个例子，如果你希望在 Squid 这样的缓存服务器上确保 RPC 被正确缓存的话可能需要一些额外的努力了。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cinwm7cpdbc0",
                            "created": 1647699192566,
                            "text": "表述性状态转移（REST）",
                            "note": "REST 是一种强制的客户端/服务端架构设计模型，客户端基于服务端管理的一系列资源操作。服务端提供修改或获取资源的接口。所有的通信必须是无状态和可缓存的。\n\nRESTful 接口有四条规则：\n- 标志资源（HTTP 里的 URI） ── 无论什么操作都使用同一个 URI。\n- 表示的改变（HTTP 的动作） ── 使用动作, headers 和 body。\n- 可自我描述的错误信息（HTTP 中的 status code） ── 使用状态码，不要重新造轮子。\n- HATEOAS（HTTP 中的HTML 接口） ── 你的 web 服务器应该能够通过浏览器访问。\n\nREST 关注于暴露数据。它减少了客户端／服务端的耦合程度，经常用于公共 HTTP API 接口设计。REST 使用更通常与规范化的方法来通过 URI 暴露资源，通过 header 来表述并通过 GET、POST、PUT、DELETE 和 PATCH 这些动作来进行操作。因为无状态的特性，REST 易于横向扩展和隔离。\n\n缺点：\n- 由于 REST 将重点放在暴露数据，所以当资源不是自然组织的或者结构复杂的时候它可能无法很好的适应。举个例子，返回过去一小时中与特定事件集匹配的更新记录这种操作就很难表示为路径。使用 REST，可能会使用 URI 路径，查询参数和可能的请求体来实现。\n- REST 一般依赖几个动作（GET、POST、PUT、DELETE 和 PATCH），但有时候仅仅这些没法满足你的需要。举个例子，将过期的文档移动到归档文件夹里去，这样的操作可能没法简单的用上面这几个 verbs 表达。\n- 为了渲染单个页面，获取被嵌套在层级结构中的复杂资源需要客户端，服务器之间多次往返通信。例如，获取博客内容及其关联评论。对于使用不确定网络环境的移动应用来说，这些多次往返通信是非常麻烦的。\n- 随着时间的推移，更多的字段可能会被添加到 API 响应中，较旧的客户端将会接收到所有新的数据字段，即使是那些它们不需要的字段，结果它会增加负载大小并引起更大的延迟。"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cinna8uct7k0",
                    "created": 1647672865450,
                    "text": "安全",
                    "note": "- 在运输和等待过程中加密\n- 对所有的用户输入和从用户那里发来的参数进行处理以防止 XSS 和 SQL 注入。\n- 使用参数化的查询来防止 SQL 注入。\n- 使用最小权限原则。"
                },
                "children": []
            }
        ]
    },
    "template": "default",
    "theme": "fresh-blue",
    "version": "1.4.43"
}