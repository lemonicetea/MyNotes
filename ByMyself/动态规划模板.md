# DP问题常见模板

## 子序列问题

### 1、一维DP数组

例如最长递增子序列问题，dp数组的定义是：在子数组array[0..i]中，以array[i]结尾的目标子序列（最长递增子序列）的长度是dp[i]。

```java
int n = array.length;
int[] dp = new int[n];

for (int i = 1; i < n; i++) {
    for (int j = 0; j < i; j++) {
        dp[i] = 最值(dp[i], dp[j] + ...)
    }
}
```

### 2、二维DP数组

涉及两个字符串/数组时（比如最长公共子序列），dp数组的定义是：在子数组arr1[0..i]和子数组arr2[0..j]中，我们要求的子序列（最长公共子序列）长度为dp[i][j]。

只涉及一个字符串/数组时（比如最长回文子序列），dp数组的定义是：在子数组array[i..j]中，我们要求的子序列（最长回文子序列）的长度为dp[i][j]。

```java
int n = arr.length;
int[][] dp = new dp[n][n];

for (int i = 0; i < n; i++) {
    for (int j = 1; j < n; j++) {
        if (arr[i] == arr[j]) 
            dp[i][j] = dp[i][j] + ...
        else
            dp[i][j] = 最值(...)
    }
}
```

## 背包问题

### 0-1背包

```java
public int knapsack(int w, int n, int[] wt, int[] val) {
    int[][] dp = new int[n + 1][w + 1];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= w; j++) {
            if (j < wt[i - 1]) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = max(dp[i - 1][j - wt[i - 1]] + val[i - 1], dp[i - 1][j]);
            }
        }
    }
    return dp[n][w];
}
```